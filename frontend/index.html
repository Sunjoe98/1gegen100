<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>1 gegen 100 – Spieler</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>1 gegen 100</h1>

  <div id="join">
    <input id="name" placeholder="Dein Name">
    <button onclick="join()">Beitreten</button>
  </div>

  <div id="game" style="display:none;">
    <div class="footer">Noch im Spiel: <span id="aliveCount">0</span> / <span id="totalCount">0</span></div>
    <h2 id="questionText">Warten auf nächste Frage…</h2>
    <div id="answers"></div>
    <div id="hint" class="badge"></div>
  </div>

  <script src="https://cdn.socket.io/4.3.2/socket.io.min.js"></script>
<script>
  const SOCKET_URL = 'https://onegegen100-u6h7.onrender.com';
  const socket = io(SOCKET_URL);

  let cells = new Map();   // number -> div.cell
  let known = new Set();

  function ensureCells(players) {
    const grid = document.getElementById('grid');
    // Alle (bekannten) Nummern stabil im Grid
    const nums = players.map(p => p.number).sort((a,b)=>a-b);
    nums.forEach(n => {
      if (!known.has(n)) {
        const d = document.createElement('div');
        d.className = 'cell alive';
        d.textContent = n;
        grid.appendChild(d);
        cells.set(n, d);
        known.add(n);
      }
    });
    // Status frisch setzen (kein Effekt auf laufende Anim.)
    players.forEach(p => {
      const c = cells.get(p.number);
      if (!c) return;
      c.classList.remove('alive','dead','elim','out');
      c.classList.add(p.alive ? 'alive' : 'out'); // bereits ausgeschiedene: rot
    });
  }

  function wait(ms){ return new Promise(r => setTimeout(r, ms)); }

  // EXAKT EINER NACH DEM ANDEREN: kurz "elim" -> dann dauerhaft "out"
  async function animateEliminationSequential(numbers) {
    for (const num of numbers) {
      const c = cells.get(num);
      if (!c) continue;
      // Start: egal was war, auf "elim"
      c.classList.remove('alive','dead','out');
      c.classList.add('elim');
      await wait(450);      // Puls-/Leuchteffekt
      // Dauerhaft rot markieren
      c.classList.remove('elim','alive','dead');
      c.classList.add('out');
      await wait(120);      // kleine Pause bis zum nächsten
    }
  }

  // Stats-Anzeige oben
  socket.on('stats', ({alive,total}) => {
    document.getElementById('aliveCount').innerText = alive;
    document.getElementById('totalCount').innerText = total;
  });

  // Grid aufbauen / Live-Status pflegen (ohne Animation)
  socket.on('updatePlayers', (players) => {
    ensureCells(players);
    players.forEach(p => {
      const c = cells.get(p.number);
      if (!c) return;
      // Wenn gerade animiert wurde, nicht zurück überschreiben.
      // Nur setzen, wenn kein "elim" läuft:
      if (!c.classList.contains('elim')) {
        c.classList.remove('alive','dead','out');
        c.classList.add(p.alive ? 'alive' : 'out');
      }
    });
  });

  // Eliminationsliste vom Backend (in Reihenfolge abspielen)
  socket.on('eliminationSequence', async ({ eliminatedNumbers }) => {
    await animateEliminationSequential(eliminatedNumbers);
  });
</script>
</body>
</html>
